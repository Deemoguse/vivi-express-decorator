{"version":3,"file":"index.js","sources":["../../node_modules/tslib/tslib.es6.js","../../src/modules/repository.ts","../../src/modules/http-methods.ts","../../src/modules/attach-controllers.ts","../../src/modules/controller.ts","../../src/modules/middleware.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.push(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.push(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","import { Method }                                     from '../types/method';\r\nimport { ClassController }                            from '../types/controller';\r\nimport { Repository, MethodRecord, ControllerRecord } from '../types/repository';\r\n\r\n/**\r\n * Repository.\r\n **/\r\nexport const repository: Repository = {\r\n\tcontrollers : new Map(),\r\n\tmethods     : new Map(),\r\n};\r\n\r\n/**\r\n * Write controller class data.\r\n * @param controller - controller class.\r\n * @param url - URL of the controller.\r\n **/\r\nexport function setController (controller: ClassController, data: ControllerRecord): void\r\n{\r\n\tif (hasController(controller))\r\n\t{\r\n\t\tconst updateData = { ...getController(controller), ...data };\r\n\t\trepository.controllers.set(controller, updateData);\r\n\t}\r\n\telse\r\n\t{\r\n\t\trepository.controllers.set(controller, data);\r\n\t}\r\n}\r\n\r\n/**\r\n * Get сontroller class data.\r\n * @param controller - controller class.\r\n **/\r\nexport function getController (controller: ClassController): ControllerRecord | undefined\r\n{\r\n\treturn repository.controllers.get(controller);\r\n}\r\n\r\n/**\r\n * Check the record for existence.\r\n * @param controller - controller class.\r\n **/\r\nexport function hasController (controller: ClassController): boolean\r\n{\r\n\treturn repository.controllers.has(controller);\r\n}\r\n\r\n/**\r\n * Get to wash down the HTTP method data.\r\n * @param controller - controller class.\r\n * @param url - URL.\r\n * @param method - HTTP method.\r\n * @param handler - сlass сontroller method.\r\n **/\r\nexport function setMethod (controller: InstanceType<ClassController>, data: MethodRecord): void\r\n{\r\n\tif (hasMethod(controller, data.handler))\r\n\t{\r\n\t\tconst updateData = { ...getMethod(controller, data.handler), ...data };\r\n\t\trepository.methods.get(controller)?.set(data.handler, updateData);\r\n\t}\r\n\telse if (repository.methods.has(controller))\r\n\t{\r\n\t\trepository.methods.get(controller)?.set(data.handler, data);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tconst map = new Map<Method, MethodRecord>();\r\n\t\t\t\tmap.set(data.handler, data);\r\n\r\n\t\trepository.methods.set(controller, map);\r\n\t}\r\n}\r\n\r\n/**\r\n * Create a wash down of the controller method.\r\n * @param controller - Controller class whose method to get.\r\n * @param method - сlass сontroller method.\r\n **/\r\nexport function getMethod (controller: InstanceType<ClassController>, method: Method): MethodRecord | undefined\r\n{\r\n\tif (repository.methods.has(controller))\r\n\t{\r\n\t\treturn repository.methods.get(controller)?.get(method);\r\n\t}\r\n\r\n\treturn undefined;\r\n}\r\n\r\n/**\r\n *\tGet a list of controller methods.\r\n * @param controller - Controller class whose methods to get.\r\n **/\r\nexport function getMethodList (controller: ClassController): Map<Method, MethodRecord> | undefined\r\n{\r\n\tif (repository.methods.has(controller.prototype))\r\n\t{\r\n\t\treturn repository.methods.get(controller.prototype);\r\n\t}\r\n\r\n\treturn undefined;\r\n}\r\n\r\n/**\r\n * Check the record for existence.\r\n * @param controller - Controller class whose method to get.\r\n * @param method - сlass сontroller method.\r\n **/\r\nexport function hasMethod (controller: InstanceType<ClassController>, method: Method): boolean\r\n{\r\n\treturn Boolean(repository.methods.get(controller)?.has(method));\r\n}","import { getMethod, hasMethod, setMethod } from './repository';\r\nimport type { ClassController }            from '../types/controller';\r\n\r\n/**\r\n * Produce a decorator function with the specified HTTP method.\r\n * @param method - HTTP method.\r\n **/\r\nfunction factoryMethodDecorators (method: string): (url: string) => Function\r\n{\r\n\t/**\r\n\t * Declare the method as an HTTP request.\r\n\t * @param url - Request URL.\r\n\t **/\r\n\treturn function (url: string): MethodDecorator\r\n\t{\r\n\t\treturn function (target: InstanceType<ClassController>, key: string | symbol): void\r\n\t\t{\r\n\t\t\tconst handler = target[key as string];\r\n\r\n\t\t\t// Record method:\r\n\t\t\tsetMethod(target, { url, method, handler });\r\n\t\t};\r\n\t};\r\n}\r\n\r\n/**\r\n * Declare this API method.\r\n * This will add a prefix to the router URL. By default, the prefix is `/api/`.\r\n * * * * * * * * *\r\n * After declaring the `@Controller` __`/post`__, as well as the `@Api` `@Post` __'/create'__ method,\r\n * you will be able to access this api at __`/api/post/create`__.\r\n **/\r\nexport function Api (): Function\r\n{\r\n\treturn function (target: InstanceType<ClassController>, key: string | symbol): void\r\n\t{\r\n\t\tif (hasMethod(target, target[key as string]))\r\n\t\t{\r\n\t\t\tconst method       = target[key as string];\r\n\t\t\tconst methodRecord = getMethod(target, method)!;\r\n\r\n\t\t\t// Modify record:\r\n\t\t\tmethodRecord.isApi = true;\r\n\r\n\t\t\t// Record new data:\r\n\t\t\tsetMethod(target, methodRecord);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthrow new ReferenceError(`Method \"${key as string}\" cannot be declared as an API because it was not declared as an HTTP method.`);\r\n\t\t}\r\n\t};\r\n}\r\n\r\n/**\r\n * Declare the Get method as an HTTP request.\r\n * @param url - Request URL.\r\n **/\r\nexport const Get = factoryMethodDecorators('get');\r\n\r\n/**\r\n * Declare Post method as an HTTP request.\r\n * @param url - Request URL.\r\n **/\r\nexport const Post = factoryMethodDecorators('post');\r\n\r\n/**\r\n * Declare Patch method as an HTTP request.\r\n * @param url - Request URL.\r\n **/\r\nexport const Patch = factoryMethodDecorators('patch');\r\n\r\n/**\r\n * Declare Put method as an HTTP request.\r\n * @param url - Request URL.\r\n **/\r\nexport const Put = factoryMethodDecorators('put');\r\n\r\n/**\r\n * Declare Head method as an HTTP request.\r\n * @param url - Request URL.\r\n **/\r\nexport const Head = factoryMethodDecorators('head');\r\n\r\n/**\r\n * Declare Delete method as an HTTP request.\r\n * @param url - Request URL.\r\n **/\r\nexport const Delete = factoryMethodDecorators('delete');\r\n\r\n/**\r\n * Declare Connect method as an HTTP request.\r\n * @param url - Request URL.\r\n **/\r\nexport const Connect = factoryMethodDecorators('connect');\r\n\r\n/**\r\n * Declare Options method as an HTTP request.\r\n * @param url - Request URL.\r\n **/\r\nexport const Options = factoryMethodDecorators('options');\r\n\r\n/**\r\n * Declare Trace method as an HTTP request.\r\n * @param url - Request URL.\r\n **/\r\nexport const Trace = factoryMethodDecorators('trace');","import { normalize }                    from 'path';\r\nimport { Router }                       from 'express';\r\nimport { getController, getMethodList } from './repository';\r\nimport type { Express }                 from 'express';\r\nimport type { ClassController }         from '../types/controller';\r\n\r\nexport function AttachController (app: Express, controllers: ClassController[]): void\r\n{\r\n\t// The router to which the methods defined as API will be registered:\r\n\tconst apiRouter = Router();\r\n\r\n\t// Registration of controllers and its methods:\r\n\tcontrollers.forEach(controller =>\r\n\t\t{\r\n\t\t\tconst controllerData = getController(controller);\r\n\r\n\t\t\t// If the controller was found, we register it in the\r\n\t\t\t// transferred instance of the express application:\r\n\t\t\tif (controllerData)\r\n\t\t\t{\r\n\t\t\t\tconst controllerRouter   = Router();\r\n\t\t\t\tconst controllerInstance = new controllerData.controller();\r\n\t\t\t\tconst controllerMethods  = getMethodList(controller)!;\r\n\r\n\t\t\t\t// It is important to bind the controller instance to\r\n\t\t\t\t// all its methods to avoid undesirable behavior:\r\n\t\t\t\tcontrollerMethods.forEach(methodRecord =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tconst router            = methodRecord.isApi ? apiRouter : controllerRouter;\r\n\t\t\t\t\t\tconst routeURL          = methodRecord.isApi ? `${controllerData.url}/${methodRecord.url}` : methodRecord.url;\r\n\t\t\t\t\t\tconst normalizeRouteURL = `/${normalize(routeURL).split(/[\\\\/]/).filter(w => w.match(/\\w+/)).join('/')}`;\r\n\r\n\t\t\t\t\t\t(router[methodRecord.method as keyof Router] as Function)(\r\n\t\t\t\t\t\t\tnormalizeRouteURL,\r\n\t\t\t\t\t\t\tmethodRecord.middlewares || [],\r\n\t\t\t\t\t\t\tmethodRecord.handler.bind(controllerInstance),\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t},\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// Register router:\r\n\t\t\t\tapp.use(\r\n\t\t\t\t\tcontrollerData.url,\r\n\t\t\t\t\tcontrollerData.middlewares || [],\r\n\t\t\t\t\tcontrollerRouter,\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthrow new ReferenceError(`Unregistered controller \"${controller.name}\" class.`);\r\n\t\t\t}\r\n\t\t},\r\n\t);\r\n\r\n\t// Register API router:\r\n\tapp.use('/api', apiRouter);\r\n}","import { setController }        from './repository';\r\nimport type { ClassController } from '../types/controller';\r\n\r\n/**\r\n * Create a wash down of controller data\r\n * @param url - Route URL.\r\n **/\r\nexport function Controller (url: string): ClassDecorator\r\n{\r\n\treturn function (controller: ClassController | Function): void\r\n\t{\r\n\t\tcontroller.prototype._routerURL = url;\r\n\t\tsetController(controller as ClassController, {\r\n\t\t\tcontroller  : controller as ClassController,\r\n\t\t\tmiddlewares : [],\r\n\t\t\turl,\r\n\t\t});\r\n\t};\r\n}","import * as repository          from './repository';\r\nimport type { Method }          from '../types/method';\r\nimport type { ClassController } from '../types/controller';\r\n\r\n/**\r\n * Use the handler as middleware.\r\n * A handler, an array of handlers, or a list\r\n * of handlers (rest spread) can be passed as an argument.\r\n * @param handler - Middleware handler.\r\n **/\r\nexport function Middleware (handler: Method<true>): Function;\r\n\r\n/**\r\n * Use the handler as middleware.\r\n * A handler, an array of handlers, or a list\r\n * of handlers (rest spread) can be passed as an argument.\r\n * @param handlers - Middleware handlers.\r\n **/\r\nexport function Middleware (...handlers: Method<true>[]): Function;\r\n\r\n/**\r\n * Use the handler as middleware.\r\n * A handler, an array of handlers, or a list\r\n * of handlers (rest spread) can be passed as an argument.\r\n * @param handlers - Middleware handlers.\r\n **/\r\nexport function Middleware (...handlers: Method<true>[]): Function\r\n{\r\n\tfunction decorator (target: ClassController, key: undefined): void;\r\n\tfunction decorator (target: InstanceType<ClassController>, key: string): void;\r\n\tfunction decorator (target: InstanceType<ClassController> | ClassController, key?: string): void\r\n\t{\r\n\t\t// If target is class. If a decorator is used for a class,\r\n\t\t// then usually the key argument will not be passed. This is\r\n\t\t// exactly what the check will consist of, what exactly the\r\n\t\t// handler will be assigned to.\r\n\t\t// -----------------------------------------------------------\r\n\t\t// #TODO: Find and use a more reliable method to determine the\r\n\t\t//        difference between a class and a regular function.\r\n\r\n\t\tif (key)\r\n\t\t{\r\n\t\t\tconst controllerPrototype = target as InstanceType<ClassController>;\r\n\r\n\t\t\tif (repository.hasMethod(controllerPrototype, controllerPrototype[key]) === false)\r\n\t\t\t{\r\n\t\t\t\t// Create empty method record:\r\n\t\t\t\trepository.setMethod(controllerPrototype, {\r\n\t\t\t\t\turl     : '',\r\n\t\t\t\t\tmethod  : '',\r\n\t\t\t\t\thandler : controllerPrototype[key],\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Modify record:\r\n\t\t\tconst methodRecord = repository.getMethod(controllerPrototype, controllerPrototype[key])!;\r\n\t\t\t\t\tmethodRecord.middlewares = Array.isArray(handlers)\r\n\t\t\t\t\t\t? [ ...(methodRecord?.middlewares || []), ...handlers ]\r\n\t\t\t\t\t\t: [ ...(methodRecord?.middlewares || []), handlers ];\r\n\r\n\t\t\t// Record new data:\r\n\t\t\trepository.setMethod(controllerPrototype, methodRecord);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tconst controller = target as ClassController;\r\n\r\n\t\t\tif (repository.hasController(controller))\r\n\t\t\t{\r\n\t\t\t\t// Create empty controller record:\r\n\t\t\t\trepository.setController(controller, { controller, url : '', middlewares : []});\r\n\t\t\t}\r\n\r\n\t\t\t// Modify record:\r\n\t\t\tconst controllerRecord = repository.getController(controller)!;\r\n\t\t\t\t\tcontrollerRecord.middlewares = Array.isArray(handlers)\r\n\t\t\t\t\t\t? [ ...(controllerRecord?.middlewares || []), ...handlers ]\r\n\t\t\t\t\t\t: [ ...(controllerRecord?.middlewares || []), handlers ];\r\n\r\n\t\t\t// Record new data\r\n\t\t\trepository.setController(controller, controllerRecord);\r\n\t\t}\r\n\t}\r\n\r\n\treturn decorator;\r\n}"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","__spreadArray","to","from","pack","ar","l","Array","slice","concat","repository","controllers","Map","methods","setController","controller","data","hasController","updateData","getController","set","get","has","setMethod","hasMethod","handler","getMethod","_a","_b","map","method","getMethodList","Boolean","factoryMethodDecorators","url","target","key","Get","Post","Patch","Put","Head","Delete","Connect","Options","Trace","ReferenceError","methodRecord","isApi","app","apiRouter","Router","forEach","controllerData","name","controllerRouter_1","controllerInstance_1","router","routeURL","normalizeRouteURL","normalize","split","filter","w","match","join","middlewares","bind","use","_routerURL","handlers","_i","decorator","controllerPrototype","repository.hasMethod","repository.setMethod","repository.getMethod","isArray","repository.hasController","repository.setController","controllerRecord","repository.getController"],"mappings":"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"}